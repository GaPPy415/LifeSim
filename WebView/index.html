<!DOCTYPE html>
<html>
<head>
  <title>Life Viewer</title>
</head>
<body>
  <div style="display:flex;flex-direction:column;align-items:center;">
    <h1>Elapsed time: 0s</h1>
    <div style="display:flex;align-items:center;justify-content:center;gap:32px;">
      <canvas id="view" width="1000" height="1000" style="border:1px solid"></canvas>
      <div style="display:flex;flex-direction:column;align-self:start;padding-top:100px;width:200px">
        <h2>Animals: 0</h2>
        <h2>Food: 0</h2>
      </div>
    </div>
  </div>
  <script>
    const socket = new WebSocket("ws://localhost:5000/ws");
    const canvas = document.getElementById("view");
    const ctx = canvas.getContext("2d");

    const lerpDuration = 100;
    const lerp = (a, b, t) => a + (b - a) * t;

    let prevEntities = {};
    let entities = {};
    let lastUpdate = performance.now();

    let recentlySpawned = {};
    let recentlyDespawned = {};

    const toPaddedNumber = (num, length = 2) => Math.floor(num).toString().padStart(length, '0');

    const getTimeString = (milliseconds) => {
        const seconds = milliseconds / 1000;
        const minutes = seconds / 60;
        const hours = minutes / 60;
        const days = hours / 24;

        const remainingStr = toPaddedNumber(milliseconds % 1000, 3);
        const secondsStr = toPaddedNumber(seconds % 60);
        const minutesStr = toPaddedNumber(minutes % 60);
        const hoursStr = toPaddedNumber(hours % 60);
        const daysStr = toPaddedNumber(days % 24);

        return `${daysStr}d ${hoursStr}h ${minutesStr}m ${secondsStr}s ${remainingStr}ms`;
    };

    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      lastUpdate = performance.now();

      let animalCount = 0;
      let foodCount = 0;

      prevEntities = { ...entities };
      entities = {};
      for (const entity of data.entities) {
        entities[entity.id] = entity;

        if (entity.type === "Animal") {
          animalCount++;
        } else if (entity.type === "Food") {
          foodCount++;
        }
      }

      for (const id in prevEntities) {
        if (id in entities) continue;
        recentlyDespawned[id] = { entity: prevEntities[id], opacity: 1 };
      }
      for (const id in entities) {
        if (id in prevEntities) continue;
        recentlySpawned[id] = 0;
      }
      const total = animalCount + foodCount;
      const animalPercent = ((animalCount / total) * 100).toFixed();
      const foodPercent = ((foodCount / total) * 100).toFixed();
      document.querySelector("h2:nth-of-type(1)").innerText = `Animals: ${animalCount}\n${animalPercent}%`;
      document.querySelector("h2:nth-of-type(2)").innerText = `Food: ${foodCount}\n${foodPercent}%`;
      document.querySelector("h1").innerText = `Elapsed time: ${getTimeString(data.timeFromStart)}`;
    };

    const renderEntity = (position, diameter, color) => {
      ctx.beginPath();
      ctx.arc(position.x, position.y, diameter / 2, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
    };

    const render = () => {
      const now = performance.now();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const t = Math.min((now - lastUpdate) / lerpDuration, 1);

      for (const id in entities) {
        const curr = entities[id];
        const prev = id in prevEntities ? prevEntities[id] : curr;

        let opacity = 1;

        if (recentlySpawned[id] !== undefined) {
          opacity = recentlySpawned[id];
          recentlySpawned[id] += 0.03 * t;
          if (recentlySpawned[id] > 1) {
            delete recentlySpawned[id];
          }
        }

        const x = lerp(prev.x, curr.x, t);
        const y = lerp(prev.y, curr.y, t);
        const color = curr.color + (Math.floor(opacity * 255)).toString(16).padStart(2, "0");
        const size = curr.size;

        renderEntity({ x, y }, size, color);
      }

      for (const id in recentlyDespawned) {
        const { entity, opacity } = recentlyDespawned[id];

        if (opacity <= 0) {
          delete recentlyDespawned[id];
          continue;
        }

        const { x, y, size } = entity;
        const color = entity.color + (Math.floor(opacity * 255)).toString(16).padStart(2, "0");

        recentlyDespawned[id].opacity -= 0.03 * t;

        renderEntity({ x, y }, size, color);
      }

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  </script>
</body>
</html>
